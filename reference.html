---
layout: default
title: Reference
---
<section class="content">
  <h1 id='title_example'>Reference</h1>
  <p> 
    Table of Contents
    <ul>
      <li><a href="#symbols">Operations for declaring symbols</a></li>
      <li><a href="#params">Operations on integers</a></li>
      <li><a href="#expressions">Affine operations on expressions</a></li>
      <li><a href="#problems">Operations used to define problems</a></li>
      <li><a href="#solvers">Operations used to solve problems</a></li>
      <li><a href="#functions">Operations used to define functions</a></li>
      <li><a href="#signum">Signum values and operations</a></li>
    </ul>
  </p>
  <h2><a name="symbols">Operations for declaring symbols</a></h2>
    <p>Symbols come in two kinds: parameter symbols, which represent an integer size parameter
      to the problem, and expression symbols, which represent a vector-valued OptiCVX expression.</p>
{% highlight scala %}
/* declare a parameter symbol n */
val n = cvxparam
/* declare an expression symbol x */
val x = cvxexpr
/* declare an input symbol a */
val a = cvxinput
{% endhighlight %}

  <h2><a name="params">Operations on integers</a></h2>
    <p>Integer patameters are bound to parameter symbols in a problem definition.  The following operations are supported
      on integers within OptiCVX. (Note that integer here refers to an integer expression of the parameters, and so regular
      Scala operations on integers are not supported.)
    </p>
{% highlight scala %}
/* an integer literal is an OptiCVX integer expression */
2
/* addition */
n + m
/* subtraction and negation */
n - m
-n
/* multiplication */
n * m
/* division by an integer literal */
/* note that this only works if there is no remainder from the division,
   regardless of what parameters are passed at runtime */
n / 2
{% endhighlight %}

  <h2><a name="expressions">Affine operations on expressions</a></h2>
    <p>OptiCVX expressions can be bound to expression symbols in a problem definition.  The following affine operations are supported
      on expressions within OptiCVX.
    </p>
{% highlight scala %}
/* a double literal is an OptiCVX expression */
3.0
/* addition */
x + y
/* subtraction and negation */
x - y
-x
/* multiplication and division by a constant */
2.0 * x
x / 5.0
/* vector concatenation */
cat(x, y)
cat(u, v, w)
/* vector indexing */
x(at)
x(at, length)
/* get the length of a vector */
x.size
/* sum of all the elements of a vector */
x.sum
/* summation based on a parameter */
/* the following example sums all the elements of vector x */
sumfor(x.size)((i) => x(i))
/* concatenation based on a parameter */
/* the following example duplicates each element of vector x */
xfor(x.size)((i) => cat(x(i), x(i)))
{% endhighlight %}

  <h2><a name="problems">Operations used to define problems</a></h2>
    <p>A problem is an OptiCVX object that represents a convex problem.  The code below defines a convex
      problem <code>prob</code>.
    </p>
{% highlight scala %}
val prob = problem(
  /* define the input parameters to the problem, as a list of parameter symbols */
  params(n, m, p, ...),
  /* declare  matrix-valued inputs would be declared */
  given(a_shape -> a, b_shape -> b, ...),
  /* define the problem variables, as a list of shape -> symbol pairs */
  over(x_shape -> x, y_shape -> y, ...), 
  /* here we can bind symbols to expressions of the previous variables */
  let(z_expr -> z, ...),
  /* constraints for the problem */
  where(
    constraint_1,
    constraint_2,
    ...
  ),
  /* the objective */
  minimize(
    objective_expr
  )
)
{% endhighlight %}
    <p>Notice that for given inputs and problem variables, a shape parameter must be specified.  For given inputs,
      use the following:</p>
{% highlight scala %}
/* define a scalar-valued input */
inputscalar
/* define a vector-valued input of length n */
inputvector(n)
/* define a m by n matrix-valued input */
inputmatrix(m, n)
{% endhighlight %}
    <p>Similarly, for problem variables, use the following:</p>
{% highlight scala %}
/* define a scalar-valued variable */
scalar
/* define a vector-valued variable of length n */
vector(n)
{% endhighlight %}

  <h2><a name="solvers">Operations used to solve problems</a></h2>
    <p>Once you have defined a problem, you can use OptiCVX to solve the problem.  Currently, OptiCVX supports two
      main methods of running solvers.  Firstly, you can emulate the solver directly within the running Scala process.
      Secondly, you can direct OptiCVX to generate C code that implements the solver, and then pass data inputs to
      that program.</p>
{% highlight scala %}
/* generate a solver */
/* this solver uses the PrimalDualOperatorSplitting method */
/* OptiCVX may support other solvers as well (see section on solvers) */
val solver = prob.gen(PrimalDualOperatorSplitting)
/* solve a problem in Scala */
/* parameters must be passed as integers */
/* inputs can be passed as either:
 *   Double (scalar)
 *   Seq[Double] (vector)
 *   Seq[Seq[Double]] (matrix)
 */
val soln = solver.solve(param_1, param_2, ...)(input_1, input_2, ...)
/* get the value of expression x in this solution
 * here, x_soln will have type Seq[Double]
 */
val x_soln = soln.resolve(x)
/* generate code for the solver in C */
val ccodeobj = solver.cgen()
/* compile the code using gcc */
val csolver = ccodeobj.compile()
/* run the generated C code
 * this produces a solution of the same form as the solution above
 */
val csoln = csolver.solve(param_1, param_2, ...)(input_1, input_2, ...)
{% endhighlight %}

  <h2><a name="constraints">Operations used to define constraints</a></h2>
    <p>Constraints are used as part of a problem or function definition.  The following operations generate constraints.</p>
{% highlight scala %}
/* equality constraint for expressions x and y */
x == y
/* inequality constraint for scalar expressions x and y */
x <= y
x >= y
/* second order cone constraint for vector expression x and scalar expression y
 * this is mathematically equivalent to norm(x) <= y
 */
in_secondorder_cone(x,y)
/* constraints based on a parameter
 * this means: for each i from 0..(len-1), constrain f(i)
 */
cfor(len)((i) => f(i))
{% endhighlight %}

  <h2><a name="functions">Operations used to define functions</a></h2>
    <p>OptiCVX also supports user definition of custom convex/concave functions.  These functions can then be composed
      with one another in accordance with the DCP ruleset.  Functions are defined as follows:</p>

{% highlight scala %}
/* here, we define the function */
val function_name = {
  /* first, we declare the symbols that are to be associated with this function */
  /* this is necessary so that the scala typing works out */
  val symbol_1 = cvxexpr
  val symbol_2 = cvxexpr
  ...
  /* next, define the function proper */
  cvxfun(
    /* define the parameters taken by the function */
    params(m, n, p, q, ...),
    /* define the matrix-valued inputs taken by this function
     * this is distinct from the expression arguments taken
     * for now, functions taking inputs is not well supported, so it
     * is best to leave this section empty
     */
    given(a_shape -> a, b_shape -> b, ...),
    /* define the arguments taken by this function */
    args(x_shape -> x, y_shape -> y, ...),
    /* define the sign of this function, as a signum expression
     * we can use x.sign, y.sign, ... as inputs where x, y, ...
     * are the argument symbols defined above
     */
    sign(sign_signum),
    /* define the monotonicy of this function in each variable */
    tonicity(tonicity_in_x, tonicity_in_y, ...),
    /* define the vexity of this function */
    vexity(vexity_signum),
    /* define the dependent variables of the function */
    over(u_shape -> u, v_shape -> y, ...),
    /* here we can bind symbols to expressions of the previous variables */
    let(z_expr -> z, ...),
    /* constraints for this function */
    where(
      constraint_1,
      constraint_2,
      ...
    ),
    /* the objective (and output of the function) is to minimize some expression */
    minimize(objective_expression)
  )
}
{% endhighlight %}

  <p>We will defer a discussion of signum values until the next section.  Once you define a function, you can use
    it as follows:</p>

{% highlight scala %}
/* apply a function to an expression (returns an expression) */
function_name(param_1, param_2, ...)(arg_1, arg_2, ...)
/* for functions with no parameters, we can shorten this to */
function_name(arg_1, arg_2, ...)
{% endhighlight %}

  <h2><a name="signum">Signum values and operations</a></h2>
    <p>In OptiCVX, a signum value refers to the possible sign of an expression.  There are four signum values:
      <ul>
        <li><em>Zero</em> (the set containing zero)</li>
        <li><em>Nonnegative</em> (the set containing all nonnegative numbers)</li>
        <li><em>Nonpositive</em> (the set containing all nonpositive numbers)</li>
        <li><em>None</em> (the set containing all numbers)</li>
      </ul>
      We extend the notions of addition, negation, and multiplication to work with these sets.  Now, note that
      the sign, monotonicity, and convexity of a DCP function can be described using a signum value.  For example,
      for convexity we say:
      <ul>
        <li>An affine function has vexity <em>zero</em>.</li>
        <li>A convex function has vexity <em>nonnegative</em>.</li>
        <li>A concave function has vexity <em>nonpositive</em>.</li>
        <li>A nonconcave, nonconvex function has vexity <em>none</em>.</li>
      </ul>
      In OptiCVX, we restrict ourselves to DCP functions which can express their sign, monotonicty, and convexity
      as signums as a function of the signs of their arguments.  This encompasses a wide class of functions.
    </p>
    <p>The following operations are supported on Signum values.</p>
{% highlight scala %}
/* a zero-signum constant */
zero
/* a nonnegative-signum constant */
nonnegative
positive
/* a nonpositive-signum constant */
nonpositive
negative
/* a none-singum constant */
none
/* sum of two signum values */
S + T
/* negation of a signum value */
-S
/* product of two signum values */
S * T
/* get the signum of an input argument x to a function */
x.sign
{% endhighlight %}

</section>