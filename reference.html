---
layout: default
title: Reference
---
<section class="content">
  <h1 id='title_example'>Reference</h1>
  <p> 
    Table of Contents
    <ul>
      <li><a href="#symbols">Operations for declaring symbols</a></li>
      <li><a href="#params">Operations on integers</a></li>
      <li><a href="#expressions">Affine operations on expressions</a></li>
      <li><a href="#problems">Operations used to define problems</a></li>
      <li><a href="#solvers">Operations used to solve problems</a></li>
    </ul>
  </p>
  <h2><a name="symbols">Operations for declaring symbols</a></h2>
    <p>Symbols come in two kinds: parameter symbols, which represent an integer size parameter
      to the problem, and expression symbols, which represent a vector-valued OptiCVX expression.</p>
{% highlight scala %}
/* declare a parameter symbol n */
val n = cvxparam
/* declare an expression symbol x */
val x = cvxexpr
/* declare an input symbol a */
val a = cvxinput
{% endhighlight %}

  <h2><a name="params">Operations on integers</a></h2>
    <p>Integer patameters are bound to parameter symbols in a problem definition.  The following operations are supported
      on integers within OptiCVX. (Note that integer here refers to an integer expression of the parameters, and so regular
      Scala operations on integers are not supported.)
    </p>
{% highlight scala %}
/* an integer literal is an OptiCVX integer expression */
2
/* addition */
n + m
/* subtraction and negation */
n - m
-n
/* multiplication */
n * m
/* division by an integer literal */
/* note that this only works if there is no remainder from the division,
   regardless of what parameters are passed at runtime */
n / 2
{% endhighlight %}

  <h2><a name="expressions">Affine operations on expressions</a></h2>
    <p>OptiCVX expressions can be bound to expression symbols in a problem definition.  The following affine operations are supported
      on expressions within OptiCVX.
    </p>
{% highlight scala %}
/* a double literal is an OptiCVX expression */
3.0
/* addition */
x + y
/* subtraction and negation */
x - y
-x
/* multiplication and division by a constant */
2.0 * x
x / 5.0
/* vector concatenation */
cat(x, y)
cat(u, v, w)
/* vector indexing */
x(at)
x(at, length)
/* get the length of a vector */
x.size
/* sum of all the elements of a vector */
x.sum
/* summation based on a parameter */
/* the following example sums all the elements of vector x */
sumfor(x.size)((i) => x(i))
/* concatenation based on a parameter */
/* the following example duplicates each element of vector x */
xfor(x.size)((i) => cat(x(i), x(i)))
{% endhighlight %}

  <h2><a name="problems">Operations used to define problems</a></h2>
    <p>A problem is an OptiCVX object that represents a convex problem.  The code below defines a convex
      problem <code>prob</code>.
    </p>
{% highlight scala %}
val prob = problem(
  /* define the input parameters to the problem, as a list of parameter symbols */
  params(n, m, p, ...),
  /* declare  matrix-valued inputs would be declared */
  given(a_shape -> a, b_shape -> b, ...),
  /* define the problem variables, as a list of shape -> symbol pairs */
  over(x_shape -> x, y_shape -> y, ...), 
  /* here we can bind symbols to expressions of the previous variables */
  let(z_expr -> z, ...),
  /* constraints for the problem */
  where(
    constraint_1,
    constraint_2,
    ...
  ),
  /* the objective */
  minimize(
    objective_expr
  )
)
{% endhighlight %}
    <p>Notice that for given inputs and problem variables, a shape parameter must be specified.  For given inputs,
      use the following:</p>
{% highlight scala %}
/* define a scalar-valued input */
inputscalar
/* define a vector-valued input of length n */
inputvector(n)
/* define a m by n matrix-valued input */
inputmatrix(m, n)
{% endhighlight %}
    <p>Similarly, for problem variables, use the following:</p>
{% highlight scala %}
/* define a scalar-valued variable */
scalar
/* define a vector-valued variable of length n */
vector(n)
{% endhighlight %}

  <h2><a name="solvers">Operations used to solve problems</a></h2>
    <p>Once you have defined a problem, you can use OptiCVX to solve the problem.  Currently, OptiCVX supports two
      main methods of running solvers.  Firstly, you can emulate the solver directly within the running Scala process.
      Secondly, you can direct OptiCVX to generate C code that implements the solver, and then pass data inputs to
      that program.</p>
{% highlight scala %}
/* generate a solver */
/* this solver uses the PrimalDualOperatorSplitting method */
/* OptiCVX may support other solvers as well (see section on solvers) */
val solver = prob.gen(PrimalDualOperatorSplitting)
/* solve a problem in Scala */
/* parameters must be passed as integers */
/* inputs can be passed as either:
 *   Double (scalar)
 *   Seq[Double] (vector)
 *   Seq[Seq[Double]] (matrix)
 */
val soln = solver.solve(param_1, param_2, ...)(input_1, input_2, ...)
/* get the value of expression x in this solution
 * here, x_soln will have type Seq[Double]
 */
val x_soln = soln.resolve(x)
/* generate code for the solver in C */
val ccodeobj = solver.cgen()
/* compile the code using gcc */
val csolver = ccodeobj.compile()
/* run the generated C code
 * this produces a solution of the same form as the solution above
 */
val csoln = csolver.solve(param_1, param_2, ...)(input_1, input_2, ...)
{% endhighlight %}
</section>